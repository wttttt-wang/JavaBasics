## Simple Factory
* 解决了创建对象的问题
### Problems
* 比如对CashFactory来说,每次添加新的促销策略,都需要改动工厂
* --> 以致代码需要重新编译部署。
* --> 更好的方式? 参考"策略模式Strategy"
* --> 其实根本上解决这个问题的方式是使用**反射**。 (Strategy并不能避免代码的修改,往下看)


## Strategy
* --> 对上面讲到的CashFactory而言,商场如何促销(打折or返利),其本质都是是算法(策略),最重要的是这些算法是随时可能替换的。
* --> 封装变化点是面向对象的一种很重要的思维方式。
* 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。


## Decorator
* 装饰模式又名包装(Wrapper)模式。装饰模式以对**客户端透明**的方式扩展对象的功能，是继承关系的一个替代方案。
* 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
  装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。
* 装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。
* --> 这里可以结合"开放-封闭原则"理解。(程序中所有依赖关系都是终止于抽象类or接口。面向抽象编程而不是面向细节编程)
* Decorator的目标是给原对象增加额外功能。


## Proxy
* proxy pattern: 为对象提供一种代理以控制对这个对象的访问。
* 目标是控制被代理对象的访问。
* 代理和被代理类继承自同一接口。实际上,代理对象内部调用的都是被代理类的方法。


## Factory Method
* 跟上述简单工厂的区别是:比如对Operation,工厂模式会对每个OperationAdd、OperationSub都创建一个具体工厂类。
* 为什么要引入Factory Method pattern呢?
* --> 因为对于Simple Factory pattern而言,当我们需要加新的operation时,对工厂部分而言,都需增加相应的创建业务逻辑
* --> 这显然违背了开闭原则。 (开闭原则: 对程序的改动是通过增加新代码,而不是更改现有代码。)
* --> 于是出现了工厂方式模式:**把工厂类定义为接口**,而每新增一种operation,都增加对应工厂类的实现,从而实现了可扩展性。
* 工厂方法模式组成
    * 抽象工厂角色:工厂方法的核心,是具体工厂角色必须实现的接口(or继承的父类)。(由抽象类or接口来实现)
    * 具体工厂角色:含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
    * 抽象产品角色：具体产品继承的父类或者是实现的接口。
    * 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。


## Template Method
* 模板方法:定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。
* --> 从而,模板方法可以使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
* 本质是把不变行为搬移到超类,去除子类中的重复代码。


## Observer
* 观察者模式又叫做 Publish/Subscribe 发布-订阅模式。
* 动机:讲一个系统分割成一系列相互协作的类存在副作用,那就是需要维护相关对象间的一致性。
       但我们不希望为了维持一致性而使各类紧密耦合(维护、扩展和重用成本高)。
* 通过抽象出"通知者Subject"和"观察者Observer",降低具体类之间的耦合。
* --> 从而让耦合的双方都**依赖于抽象,而不是依赖于具体**。


## Abstract Factory
* 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。
* 使用场景:系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
* items:
    * 超级工厂(工厂的工厂)
    * 各个(产品族的)工厂
    * FactoryProducer,用于获取具体的工厂。


## Iterator
* 迭代器模式:提供一种方法顺序访问一个聚合对象中各个元素,而又**不暴露**该对象的内部表示。


## Singleton
* 创建性模式,提供了一种创建对象的最佳方式。
* 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
* 使用场景:当一个全局使用的类频繁地被创建与销毁,保证一个类一个实例。