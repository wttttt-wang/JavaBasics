## Simple Factory
* 解决了创建对象的问题
### Problems
* 比如对CashFactory来说,每次添加新的促销策略,都需要改动工厂
* --> 以致代码需要重新编译部署。
* --> 更好的方式? 参考"策略模式Strategy"
* --> 其实根本上解决这个问题的方式是使用**反射**。 (Strategy并不能避免代码的修改,往下看)


## Strategy
* --> 对上面讲到的CashFactory而言,商场如何促销(打折or返利),其本质都是是算法(策略),最重要的是这些算法是随时可能替换的。
* --> 封装变化点是面向对象的一种很重要的思维方式。
* 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。


## Decorator
* 装饰模式又名包装(Wrapper)模式。装饰模式以对**客户端透明**的方式扩展对象的功能，是继承关系的一个替代方案。
* 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
  装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。
* 装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。
* --> 这里可以结合"开放-封闭原则"理解。(程序中所有依赖关系都是终止于抽象类or接口。面向抽象编程而不是面向细节编程)
* Decorator的目标是给原对象增加额外功能。


## Proxy
* proxy pattern: 为对象提供一种代理以控制对这个对象的访问。
* 目标是控制被代理对象的访问。
* 代理和被代理类继承自同一接口。实际上,代理对象内部调用的都是被代理类的方法。


## Factory Method
* 跟上述简单工厂的区别是:比如对Operation,工厂模式会对每个OperationAdd、OperationSub都创建一个具体工厂类。
* 为什么要引入Factory Method pattern呢?
* --> 因为对于Simple Factory pattern而言,当我们需要加新的operation时,对工厂部分而言,都需增加相应的创建业务逻辑
* --> 这显然违背了开闭原则。 (开闭原则: 对程序的改动是通过增加新代码,而不是更改现有代码。)
* --> 于是出现了工厂方式模式:**把工厂类定义为接口**,而每新增一种operation,都增加对应工厂类的实现,从而实现了可扩展性。
* 工厂方法模式组成
    * 抽象工厂角色:工厂方法的核心,是具体工厂角色必须实现的接口(or继承的父类)。(由抽象类or接口来实现)
    * 具体工厂角色:含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
    * 抽象产品角色：具体产品继承的父类或者是实现的接口。
    * 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。


## Template Method
* 模板方法:定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。
* --> 从而,模板方法可以使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
* 本质是把不变行为搬移到超类,去除子类中的重复代码。